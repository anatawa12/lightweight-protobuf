val int = Template(
    primitive = "int",
    Boxed = "Integer",
)
val long = Template(
    primitive = "long",
    Boxed = "Long",
)
val float = Template(
    primitive = "float",
    Boxed = "Float",
    PrimitiveIter = "FloatIterator",
    addUnaryOperatorImport = false,
)
val double = Template(
    primitive = "double",
    Boxed = "Double",
)
val boolean = Template(
    primitive = "boolean",
    Boxed = "Boolean",
    PrimitiveIter = "BooleanIterator",
    addUnaryOperatorImport = false,
)

val baseDir = "src/main/java/com/anatawa12/protobuf"

int.generateAll()
long.generateAll()
float.generateAll()
double.generateAll()
boolean.generateAll()

class Template(
    val primitive: String,
    val Boxed: String,
    val Primitive: String = primitive[0].toUpperCase() + primitive.substring(1),
    val PrimitiveIter: String = "PrimitiveIterator.Of$Primitive",
    val addUnaryOperatorImport: Boolean = true,
) {
    val ListName: String = "${Primitive}List"
    val ImmutableListName: String = "Immutable${Primitive}List"

    fun generateAll() {
        java.io.File("$baseDir/$ListName.java")
            .writeText(generateMain())
        java.io.File("$baseDir/$ImmutableListName.java")
            .writeText(generateImmutable())
        if (!addUnaryOperatorImport) {
            java.io.File("$baseDir/${Primitive}UnaryOperator.java")
                .writeText(generateUnaryOperator())
            java.io.File("$baseDir/${Primitive}Iterator.java")
                .writeText(generateIterator())
            java.io.File("$baseDir/${Primitive}Consumer.java")
                .writeText(generateConsumer())
        }
    }

    private fun unaryOperatorImport() = if (!addUnaryOperatorImport) ""
    else "\nimport java.util.function.${Primitive}UnaryOperator;"

    val header = """
        /*
         * Generated by lists-generator.kts
         */
        
    """.trimIndent()

    fun generateMain() = """$header
package com.anatawa12.protobuf;

import java.lang.reflect.Array;
import java.util.AbstractList;
import java.util.Arrays;
import java.util.Collection;
import java.util.ConcurrentModificationException;
import java.util.List;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.PrimitiveIterator;
import java.util.RandomAccess;${unaryOperatorImport()}

public class $ListName extends AbstractList<$Boxed> implements List<$Boxed>, RandomAccess {
    protected int size;
    protected $primitive[] backed;

    public $ListName() {
        this(10, 1);
    }

    public $ListName(int capacity) {
        this(capacity == 0 ? 1 : capacity, 0);
    }

    public $ListName($ListName from) {
        this(from.size());
        addAll(from);
    }

    // internal: in this constructor, empty backed array is allowed 
    // but it may cause infinity loop or index out of exeption on adding value.
    $ListName(int capacity, int marker) {
        this.backed = new $primitive[capacity];
    }

    // Query Operations

    @Override
    public final int size() {
        return size;
    }

    @Override
    public final boolean isEmpty() {
        return size == 0;
    }

    public final boolean contains($primitive element) {
        for ($primitive value : backed) {
            if (value == element)
                return true;
        }
        return false;
    }

    /**
     * You should use {@link $ListName#contains($primitive)}
     */
    @Deprecated
    @Override
    public final boolean contains(Object o) {
        if (!(o instanceof $Boxed)) return false;
        return contains(($primitive)o);
    }

    @Override
    public final $PrimitiveIter iterator() {
        return new ListIterator(0);
    }

    @Override
    public final Object[] toArray() {
        return toArray(new Object[0]);
    }

    @SuppressWarnings("unchecked")
    @Override
    public final <T> T[] toArray(T[] a) {
        // create new array if size is not enough
        if (a.length < size) a = (T[]) Array.newInstance(a.getClass().getComponentType(), size);
        for (int i = 0; i < size; i++) {
            a[i] = (T)($Boxed)backed[i];
        }
        return a;
    }

    public final $primitive[] to${Primitive}Array() {
        return Arrays.copyOf(backed, size);
    }

    // Modification Operations

    public boolean add($primitive value) {
        add(size(), value);
        return true;
    }

    /**
     * You should use {@link $ListName#add($primitive)}
     */
    @Deprecated
    @Override
    public final boolean add($Boxed boxed) {
        return add(($primitive)boxed);
    }

    /**
     * You should use {@link $ListName#remove$Primitive($primitive)}
     */
    @Deprecated
    @Override
    public final boolean remove(Object o) {
        if (!(o instanceof $Boxed))
            return false;
        return remove$Primitive(($primitive)o);
    }

    public boolean remove$Primitive($primitive value) {
        int i = indexOf(value);
        if (i < 0) return false;
        removeAt(i);
        return true;
    }

    // Bulk Modification Operations

    @Override
    public final boolean containsAll(Collection<?> c) {
        java.util.Iterator<?> iter = c.iterator();
        if (iter instanceof $PrimitiveIter) {
            $PrimitiveIter of$Primitive = ($PrimitiveIter) iter;
            while (of$Primitive.hasNext())
                if (!contains(of$Primitive.next$Primitive()))
                    return false;
        } else {
            while (iter.hasNext())
                if (!contains(iter.next()))
                    return false;
        }
        return true;
    }

    public boolean addAll($primitive[] c) {
        return addAll(size, c, c.length);
    }

    public boolean addAll(int index, $primitive[] c) {
        return addAll(index, c, c.length);
    }

    @Override
    public boolean addAll(Collection<? extends $Boxed> c) {
        if (c == this) throw new IllegalArgumentException("can't addAll this itself");
        if (c instanceof $ListName)
            return addAll(size, (($ListName) c).backed, (($ListName) c).size);
        return addAll(size, toPrimitives(c));
    }

    @Override
    public boolean addAll(int index, Collection<? extends $Boxed> c) {
        if (c == this) throw new IllegalArgumentException("can't addAll this itself");
        if (c instanceof $ListName)
            return addAll(index, (($ListName) c).backed, (($ListName) c).size);
        return addAll(index, toPrimitives(c));
    }

    private boolean addAll(int index, $primitive[] c, int addSize) {
        rangeCheckForAdd(index);
        modCount++;
        if (addSize == 0) return false;
        $primitive[] ary;
        if (backed.length < size + addSize) {
            int newSize = backed.length * 2;
            while (newSize < size + addSize) newSize *= 2;
            ary = new $primitive[newSize];
            // copy 0..<index
            System.arraycopy(backed, 0,
                    ary, 0, index);
            backed = ary;
        } else {
            ary = backed;
            // no resize
        }
        // copy index..<size to index+addSize..<size+addSize
        System.arraycopy(backed, index,
                ary, index + addSize, size - index);
        // copy 0..<addSize to index..<index+addSize
        System.arraycopy(c, 0,
                ary, index, addSize);
        size += addSize;
        return true;
    }

    @Override
    public boolean removeAll(Collection<?> c) {
        return batchRemove(c, true);
    }

    @Override
    public boolean retainAll(Collection<?> c) {
        return batchRemove(c, false);
    }

    private boolean batchRemove(Collection<?> c, boolean complement) {
        final $primitive[] data = this.backed;
        int r = 0;
        int w = 0;
        boolean modified = false;
        try {
            if (c instanceof $ListName) {
                $ListName intList = ($ListName) c;
                for (; r < size; r++)
                    if (intList.contains(data[r]) == complement)
                        data[w++] = data[r];
            } else {
                for (; r < size; r++)
                    if (c.contains(data[r]) == complement)
                        data[w++] = data[r];
            }
        } finally {
            // Preserve behavioral compatibility with AbstractCollection,
            // even if c.contains() throws.
            if (r != size) {
                System.arraycopy(data, r,
                        data, w,
                        size - r);
                w += size - r;
            }
            if (w != size) {
                size = w;
                modified = true;
            }
        }
        return modified;
    }

    public final void replaceAll(${Primitive}UnaryOperator operator) {
        Objects.requireNonNull(operator);
        final ListIterator li = this.listIterator();
        while (li.hasNext()) {
            li.set(operator.applyAs$Primitive(li.next$Primitive()));
        }
    }

    @Override
    public void clear() {
        size = 0;
    }

    public final boolean equals(Object o) {
        if (o == this) return true;
        if (!(o instanceof List<?>)) return false;
        if (o instanceof $ListName) {
            if ((($ListName) o).size != size) return false;

            ListIterator e1 = listIterator();
            ListIterator e2 = (($ListName) o).listIterator();
            while (e1.hasNext() && e2.hasNext()) {
                if (e1.next$Primitive() != e2.next$Primitive())
                    return false;
            }
            return !(e1.hasNext() || e2.hasNext());
        }

        ListIterator e1 = listIterator();
        java.util.ListIterator<?> e2 = ((List<?>) o).listIterator();
        while (e1.hasNext() && e2.hasNext()) {
            $primitive o1 = e1.next$Primitive();
            Object o2 = e2.next();
            if (!eq(o1, o2))
                return false;
        }
        return !(e1.hasNext() || e2.hasNext());
    }

    @Override
    public final int hashCode() {
        int hashCode = 1;
        final ListIterator li = this.listIterator();
        while (li.hasNext())
            hashCode = 31 * hashCode + $Boxed.hashCode(li.next$Primitive());
        return hashCode;
    }

    // Positional Access Operations

    public final $primitive get$Primitive(int index) {
        rangeCheck(index);
        return backed[index];
    }

    /**
     * You should use {@link $ListName#get$Primitive get$Primitive}
     */
    @Deprecated
    @Override
    public final $Boxed get(int index) {
        return get$Primitive(index);
    }

    public $primitive set(int index, $primitive element) {
        rangeCheck(index);
        $primitive r = backed[index];
        backed[index] = element;
        return r;
    }

    /**
     * You should use {@link $ListName#set(int, $primitive)}
     */
    @Deprecated
    @Override
    public final $Boxed set(int index, $Boxed element) {
        return set(index, ($primitive)element);
    }

    public void add(int index, $primitive value) {
        rangeCheckForAdd(index);
        modCount++;
        $primitive[] ary;
        if (backed.length < size + 1) {
            ary = new $primitive[backed.length * 2];
            // copy 0..<index
            System.arraycopy(backed, 0,
                    ary, 0, index);
            backed = ary;
        } else {
            ary = backed;
            // no resize
        }
        // copy index..<size to index+1..<size+1
        System.arraycopy(backed, index,
                ary, index + 1, size - index);
        ary[index] = value;
        size++;
    }

    /**
     * You should use {@link $ListName#add(int, $primitive)}
     */
    @Deprecated
    @Override
    public void add(int index, $Boxed element) {
        add(index, ($primitive)element);
    }

    public $primitive removeAt(int index) {
        rangeCheck(index);
        modCount++;
        $primitive r = backed[index];
        // copy index+1..<size to index..<size-1
        System.arraycopy(backed, index + 1,
                backed, index, size - index - 1);
        size--;
        return r;
    }

    /**
     * You should use {@link $ListName#removeAt removeAt}
     */
    @Deprecated
    @Override
    public $Boxed remove(int index) {
        return removeAt(index);
    }

    /**
     * You should use {@link $ListName#indexOf($primitive)}
     */
    @Override
    public final int indexOf(Object o) {
        if (!(o instanceof $Boxed)) return -1;
        return indexOf(($primitive)o);
    }

    public final int indexOf($primitive value) {
        for (int i = 0; i < size; i++) {
            if (value == backed[i]) return i;
        }
        return -1;
    }

    /**
     * You should use {@link $ListName#lastIndexOf($primitive)}
     */
    @Override
    public final int lastIndexOf(Object o) {
        if (!(o instanceof $Boxed)) return -1;
        return indexOf(($primitive)o);
    }

    public final int lastIndexOf($primitive value) {
        for (int i = size - 1; i >= 0; i--) {
            if (value == backed[i]) return i;
        }
        return -1;
    }

    // List Iterators

    @Override
    public final ListIterator listIterator() {
        return new ListIterator(0);
    }

    @Override
    public final ListIterator listIterator(int index) {
        rangeCheckForAdd(index);
        return new ListIterator(index);
    }

    public final class ListIterator implements $PrimitiveIter, java.util.ListIterator<$Boxed> {
        int expectedModCount = modCount;
        int lastRet = -1;
        int cursor;

        public ListIterator(int cursor) {
            this.cursor = cursor;
        }

        @Override
        public boolean hasNext() {
            return cursor < size;
        }

        @Override
        public $primitive next$Primitive() {
            try {
                checkForComodification();
                int i = cursor;
                $primitive next = get$Primitive(i);
                lastRet = i;
                cursor = i + 1;
                return next;
            } catch (IndexOutOfBoundsException e) {
                checkForComodification();
                throw new NoSuchElementException();
            }
        }

        @Override
        public $Boxed next() {
            return $PrimitiveIter.super.next();
        }

        public void remove() {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                $ListName.this.removeAt(lastRet);
                if (lastRet < cursor)
                    cursor--;
                lastRet = -1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException e) {
                throw new ConcurrentModificationException();
            }
        }

        public boolean hasPrevious() {
            return cursor != 0;
        }

        public $primitive previous$Primitive() {
            checkForComodification();
            try {
                int i = cursor - 1;
                $primitive previous = get$Primitive(i);
                lastRet = cursor = i;
                return previous;
            } catch (IndexOutOfBoundsException e) {
                checkForComodification();
                throw new NoSuchElementException();
            }
        }

        public int nextIndex() {
            return cursor;
        }

        public int previousIndex() {
            return cursor-1;
        }

        public void set($primitive e) {
            if (lastRet < 0)
                throw new IllegalStateException();
            checkForComodification();

            try {
                $ListName.this.set(lastRet, e);
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        public void add($primitive e) {
            checkForComodification();

            try {
                int i = cursor;
                $ListName.this.add(i, e);
                lastRet = -1;
                cursor = i + 1;
                expectedModCount = modCount;
            } catch (IndexOutOfBoundsException ex) {
                throw new ConcurrentModificationException();
            }
        }

        public void set($Boxed e) {
            set(($primitive)e);
        }
        public void add($Boxed e) {
            add(($primitive)e);
        }

        public $Boxed previous() {
            return previous$Primitive();
        }

        private void checkForComodification() {
            if (modCount != expectedModCount)
                throw new ConcurrentModificationException();
        }
    }

    //////////////////////

    private $primitive[] toPrimitives(Collection<? extends $Boxed> c) {
        $Boxed[] wrapper = c.toArray(EMPTY_WRAPPER_ARRAY);
        if (wrapper.length == 0) return EMPTY_PRIMITIVE_ARRAY;
        $primitive[] primitives = new $primitive[wrapper.length];
        for (int i = 0; i < primitives.length; i++) {
            primitives[i] = wrapper[i];
        }
        return primitives;
    }

    private void rangeCheck(int index) {
        if (index < 0 || index >= size())
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    private void rangeCheckForAdd(int index) {
        if (index < 0 || index > size())
            throw new IndexOutOfBoundsException(outOfBoundsMsg(index));
    }

    private String outOfBoundsMsg(int index) {
        return "Index: "+index+", Size: "+size();
    }

    private boolean eq($primitive o1, Object o2) {
        return o2 instanceof $Boxed && o1 == ($primitive)o2;
    }

    private static final $Boxed[] EMPTY_WRAPPER_ARRAY = new $Boxed[0];
    private static final $primitive[] EMPTY_PRIMITIVE_ARRAY = new $primitive[0];
}
"""

    fun generateImmutable() = """$header
package com.anatawa12.protobuf;

import java.util.Collection;

public final class $ImmutableListName extends $ListName {
    // Query Operations are implemented in $ListName
    // Modification Operations are not allowed. throws UnsupportedOperationException

    public $ImmutableListName($ListName copyFrom) {
        // empty backed array is safe because can't add anything with this list
        super(copyFrom.size(), 0);
        super.addAll(copyFrom);
    }

    public static final $ImmutableListName EMPTY = new $ImmutableListName(new $ListName());

    public static $ImmutableListName wrap($ListName list) {
        if (list == null) return EMPTY;
        if (list instanceof $ImmutableListName) return ($ImmutableListName) list;
        return new $ImmutableListName(list);
    }

    @Override
    public boolean add($primitive value) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean remove$Primitive($primitive value) {
        throw new UnsupportedOperationException();
    }

    public boolean addAll($primitive[] c) {
        throw new UnsupportedOperationException();
    }

    public boolean addAll(int index, $primitive[] c) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean addAll(Collection<? extends $Boxed> c) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean addAll(int index, Collection<? extends $Boxed> c) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean removeAll(Collection<?> c) {
        throw new UnsupportedOperationException();
    }

    @Override
    public boolean retainAll(Collection<?> c) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void clear() {
        throw new UnsupportedOperationException();
    }

    public $primitive set(int index, $primitive element) {
        throw new UnsupportedOperationException();
    }

    public void add(int index, $primitive value) {
        throw new UnsupportedOperationException();
    }

    /**
     * You should use {@link $ListName#add(int, $primitive)}
     */
    @SuppressWarnings("deprecation")
    @Deprecated
    @Override
    public void add(int index, $Boxed element) {
        throw new UnsupportedOperationException();
    }

    public $primitive removeAt(int index) {
        throw new UnsupportedOperationException();
    }
}
"""

    fun generateUnaryOperator() = """$header
package com.anatawa12.protobuf;

import java.util.Objects;

@FunctionalInterface
public interface ${Primitive}UnaryOperator {
    $primitive applyAs${Primitive}($primitive operand);

    default ${Primitive}UnaryOperator compose(${Primitive}UnaryOperator before) {
        Objects.requireNonNull(before);
        return ($primitive v) -> applyAs${Primitive}(before.applyAs${Primitive}(v));
    }

    default ${Primitive}UnaryOperator andThen(${Primitive}UnaryOperator after) {
        Objects.requireNonNull(after);
        return ($primitive t) -> after.applyAs${Primitive}(applyAs${Primitive}(t));
    }

    static ${Primitive}UnaryOperator identity() {
        return t -> t;
    }
}
""".trimIndent()

    fun generateIterator() = """$header
package com.anatawa12.protobuf;

import java.util.Objects;
import java.util.PrimitiveIterator;
import java.util.function.Consumer;

public interface ${Primitive}Iterator extends PrimitiveIterator<$Boxed, ${Primitive}Consumer> {
    $primitive next${Primitive}();

    default void forEachRemaining(${Primitive}Consumer action) {
        Objects.requireNonNull(action);
        while (hasNext())
            action.accept(next${Primitive}());
    }

    /**
     * {@inheritDoc}
     */
    @Override
    default $Boxed next() {
        return next${Primitive}();
    }

    /**
     * {@inheritDoc}
     */
    @Override
    default void forEachRemaining(Consumer<? super $Boxed> action) {
        if (action instanceof ${Primitive}Consumer) {
            forEachRemaining((${Primitive}Consumer) action);
        } else {
            // The method reference action::accept is never null
            Objects.requireNonNull(action);
            forEachRemaining((${Primitive}Consumer) action::accept);
        }
    }
}
""".trimIndent()

    fun generateConsumer() = """$header
package com.anatawa12.protobuf;

import java.util.Objects;

@FunctionalInterface
public interface ${Primitive}Consumer {
    void accept($primitive value);

    default ${Primitive}Consumer andThen(${Primitive}Consumer after) {
        Objects.requireNonNull(after);
        return ($primitive t) -> { accept(t); after.accept(t); };
    }
}
""".trimIndent()
}
